title: C++11
date: 2015-06-27 09:40:50
categories: [C/C++,翻译]
tags: C++11
---

译自：https://en.wikipedia.org/wiki/C++11

`C++11`（原先被称作`C++0x`，[因为它是被预计在2010之前发布][1])）是C++语言标准的一个版本。它被[`ISO`][2])在2011年8月12日批准，来替代[`C++03`][3])的，并且在2014年8月18日被[`C++14`][4])取代。命名沿用了语言版本的传统命名方式：根据规范的发布年限。

`C++11`对[语言核心][5])增加了一些特性，扩展了[C++标准库][6])，合并了[技术报告1][7])(TR1)中的大多数库--除了数学专用函数库以外。`C++11`在2011年9月作为[`ISO/IEC 14882:2011`][8])标准被发布，而且它是收费的。最接近已发布的`C++11`标准的工作草案是[`N3337`][9])，于2012年1月16日发布；它只包括`C++11`标准的编辑修正。

<!-- more -->

## 相对前一标准版本的变化

C++的条款修订包含语言核心和标准库两个方面。

2011标准的每一个设施的制定，委员会都会运用一些准则：
- 保持稳定、兼容[`C++98`][10]和尽可能兼容C
- 宁愿使用标准库来引入新特性，而不扩展语言核心
- 做出改变来发展编程技术
- 改进C++来增强系统和库的设计，而不是只为了特定应用增加新特性
- 通过对先前不安全的技术提供更安全的替代方案，来增加类型安全性
- 提升性能和直接于硬件工作的能力
- 为现实问题提供适当的解决方案
- 实施“零开销”原则（如果使用某些设施，那么它所需要的附加支持也必须要被使用）
- 使得C++容易被教授和学习，而不需要去掉一些被专家程序员使用的设施

关注初学者被认为是是重要的，因为他们总是构成计算机程序员的大多数；而且许多初学者不打算扩展他们的C++知识，这样就限制了他们只运用语言与他们专业相关的一些方面。

## 对C++语言核心的扩展

C++委员会的一个职责是发展语言核心。语言核心领域的改进意义重大，包括：多线程支持、泛型编程支持、统一初始化和性能。
为了本文的需要，语言核心特性和其改变被分为四个通用的部分：运行时性能增强、编译时性能增强、易用性增强和新功能。某些特性可以被归在多个组里，但它们只在最能代表它的组里被提到。

### 语言核心运行时性能增强

这些语言特性的存在主要是为了提供一些性能增益，无论是内存还是运算速度。

#### 右值引用和移动构造函数

在`C++03`（和以前），临时变量（术语"rvalues"，因为它们常常在赋值的右边）是为了不被修改--就像C中一样--而且被认为同`const T&`类型区分开来；然而，有时候，临时变量可以被修改，这一行为甚至被认为是一个有用的漏洞。`C++11`新曾了一个叫右值引用的非常量引用，定义为`T&&`。它是指临时变量在初始化之后可以被修改，目的是为了允许“移动语义”。

`C++03`带来的一个长期的性能问题是：当对象通过值传递时代价很高和不必要的深拷贝会暗地里发生。为了阐明这个问题，暂且把`std::vector<T>`在内部认为是一个带有大小的C风格数组的包装。如果一个`std::vector<T>`临时变量被创建或被一个函数返回，它只可以通过新创建一个`std::vector<T>`来存储，并拷贝右值的所有数据到它里面。然后，这个临时变量和它的所有内存被销毁。（为了简单起见，这一讨论忽略了[返回值优化][11]。）

在`C++11`中，`std::vector<T>`的[移动构造函数][12]可以接受一个`std::vector<T>`类型的右值引用，能够从该右值中复制那个内部C风格数组的指针到这个新的`std::vector<T>`中，然后把右值内部的指针设为空。由于这个临时变量不会再被使用，没有代码会试图去访问这个空指针，并且因为这个指针是个空指针，当它超出作用域时，它的内存并不会被删除。因此，这一操作不仅去掉了深拷贝的开销，而且是安全和无形的。

右值引用可以在对标准库之外的现有代码不做任何改变的基础上带来性能优势。返回`std::vector<T>`的函数的返回值不用显示的改变成`std::vector<T> &&`来调用移动构造函数，因为临时变量会自动的被认为是右值。（然而，如果`std::vector<T>`是`C++03`版本的，没有移动构造函数，那么拷贝构造函数就会通过`const std::vector<T>&`被调用，导致一个大内存被分配。）

出于安全原因，加了一些限制。一个命名变量绝不会被认为是一个右值，即使它声明成这样；应该使用模板函数`std::move()`来得到一个右值。右值引用也只能在某些情况下被修改，其目的主要是同移动构造函数一起使用。

归因于右值引用语法的性质，和对左值引用语法（常规引用）的一些修改，右值引用允许开发者提供完美的函数转发。当结合[可变模板](#可变模板)时，这一能力允许函数模板能够完美的转发参数给其它接受相同特定参数的函数。用它来转发够构造函数的参数非常有用：使用它创建一个工厂函数，工厂函数会自动的为这些特定的参数调用正确的构造函数。这已在[emplace_back][13]，C++的标准库方法集，中见到过了。

#### `constexpr` -- 广义的常量表达式

C++一直拥有常量表达式的概念。它们是如同`3+4`这样总是在编译时和运行时产生同样结果的表达式。常量表达式是编译器进行优化的机会，编译器经常在编译时执行它们，而把结果硬编码到程序里。而且，在许多地方，C++标准指出要使用常量表达式。定义一个数组需要一个常量表达式，枚举值必须是常量表达式。

然而，常量表达式从来并没有被允许包含一个函数调用或者一个对象构造函数。因此，如同这样简单的代码是非法的：

```C++
int get_five() {return 5;}
int some_value[get_five() + 7];  // Create an array of 12 integets. Ill-formed C++
```

在`C++03`中这不合法，因为`get_five() + 7`并不是一个常量表达式。`C++03`的编译器并没有方法知道`get_five`在运行时确实是一个常量。理论上，这一函数可能会影响一个全局变量，调用其它的非运行时常量函数，等等。

`C++11`引入了`constexpr`关键字，允许用户保证一个函数或对象构造函数是一个编译时常量。上面的例子可以被重写为一下形式：

```C++
constexpr int get_five() {return 5;}
int some_value[get_five() + 7];  // Create an array of 12 integets. Legal C++11
```

这使得编译器理解、证实`get_five()`是一个编译时常量。

在函数上使用`constexpr`会给该函数所做的事情强加一些限制。首先，该函数必须有一个非空的返回类型。第二，函数体不能声明变量或定义新类型。第三，函数体只能包含声明、空语句和一条`ruturn`语句；`return`语句必须存在参数值，以至于在参数替换之后，`return`语句的表达式产生一个常量表达式。

在`C++11`以前，变量的值只有在变量被声明为`const`，并且有一个常量表达式的初始化式，而且只能是整形或枚举类型 的情况下，才可以用在常量表达式中。`C++11`去掉了变量必须是整形或枚举这一限制，如果在它们使用`constexpr`关键字来定义：

```C++
constexpr double earth_gravitational_acceleration = 9.8;
constexpr double moon_gravitational_acceleration = earth_gravitational_acceleration / 6.0;
```

这些数据变量是隐式的常量，它们必须有初始化式，且初始化式必须是常量表达式。

为了从用户自定义类型来构造常量表达式数据值，构造函数也必须用`constexpr`声明。一个`constexpr`构造函数的函数体只能包含声明和空语句，不能声明变量或定义类型，如同一个`constexpr`函数一样。必须存在参数值，以至于在参数替换之后，把类成员初始化为常量表达式。这种类型的析构函数必须是`trivial`的。

具有任何`constexpr`构造函数的类型，它的拷贝构造函数通常也应该被定义为一个`constexpr`构造函数，为了让该类型的对象能够从一个`constexpr`函数中以值的方式返回。一个类的任何成员函数，例如：拷贝构造函数、操作符重载等等，都可以被声明为`constexpr`，只要它们被`constexpr`函数所需要。这使得编译器在编译时拷贝类、在它们上执行操作，等等。

如果一个`constexpr`函数或构造函数被使用非常量表达式的参数调用，那么这个调用行为就像该函数不是一个`constexpr`一样，其返回值也不是一个常量表达式。同样的，如果一个`constexpr`函数的`return`语句中的表达式对于一个特定的调用不能求值成一个常量表达式，那么其返回值也不是一个常量表达式。

#### 修改对`plain old data`的定义

在`C++03`中，一个`class`或`struct`必须遵守许多规则才被认为是[`plain old data`][1]4)(POD)类型。符合这一定义的类型产生的对象布局是于C兼容的，并且它们被静态的初始化。`C++03`标准对什么样的类型是C兼容的或能够被静态初始化的具有限制，尽管没有技术上的原因使编译器不能接受；如果有人创建了一个`C++03`的`POD`类型，但在它上面增加了一个非虚的成员函数，那么这个类型就不在是一个`POD`类型了，不能够被静态初始化，也不能于C兼容了，尽管在内存结构上没有变化。

`C++11`放松了几个对`POD`的规则，通过把`POD`拆分为两个不同的独立概念：`trivial`和标准布局。

一个类型是`trivial`的就能够被静态初始化。也意味着通过`memcpy`来拷贝数据是合法的，而不需要使用拷贝构造函数。一个`trivial`类型的生命周期开始于它的存储被定义的时刻，而不是构造函数完成的时刻。

`trivial` `class`或`struct`被定义为一个：
1. 有一个`trivial`默认构造函数。可以使用[default构造函数语法](#显示的被默认和被删除的特殊成员函数)(`SomeConstructor() = default;`)。
2. 有`trivial`拷贝和移动构造函数，可以使用`default`语法。
3. 有`trivial`拷贝和移动赋值操作符，可以使用`default`语法。
4. 有`trivial`析构函数，不能是虚函数。

一个类只有在它没有虚函数和没有虚基类的情况下，它的构造函数才能使是`trivial`的。拷贝/引动操作符要求类的所有非静态数据成员是`trivial`的。

一个类型是标准布局的，意味着它的成员的排序和打包方式和C兼容。一个`class`或`struct`是标准布局的，其定义如下：
1. 没有虚函数
2. 没有虚基类
3. 所有非静态数据成员具有相同的访问控制（`public`、`private`、`pritected`）
4. 所有非静态数据成员，包括基类的，在层次结构中处于同一个类中
5. 所有的基类和在类层次结构中的所有非静态数据成员都要符合上面的规则
6. 没有基类使用相同类型作为其第一个非静态数据成员

一个`class/struct/union如果是`trivial`的、标准布局的，而且其所有的非静态数据成员或基类是`POD`的，就被认为是`POD`。

通过对概念的隔离，使得放弃其中一个而不影响另一个概念。一个拥有复杂移动和拷贝构造函数的类可能不是`trivial`的，但它是标准布局的，能够和C交互操作。同样的，一个拥有`public`和`private`的非静态数据成员的类不会是标准布局的，但它可能是`trivial`的，因此能够使用`memcpy`。


### 语言核心编译时性能增强

#### 外部模板

在`C++03`中，编译器每当在翻译单元中遇到一个完全指定的模板时，必须实例化一个模板。如果一个模板在许多翻译单元中被实例化为相同类型，这会显著地增加编译时间。在`C++03`中没有办法来阻止这一点，因此`C++11`引入了外部模板声明，如同外部数据声明一样。`C++03`使用这一语法来迫使编译器实例化一个模板：

```C++
template class std::vector<MyClass>;
```

现在，`C++11`提供了下面的语法：

```C++
extern template class std::vector<MyClass>;
```

这会告诉编译器不要在这一翻译单元中实例化该模板。


### 语言核心可用性增强

这些特性存在的主要目的是是语言使用起来变得更简单。它们能够改进类型安全、最小化代码重复、使错误代码的可能性减小，等等。


#### 初始化列表

`C++03`从C中继承了初始化列表特性。结构体或数值接受一个使用大括号括起来的参数列表，按照结构体成员定义的顺序。这些初始化列表是递归的，因此结构体的数值或结构体中包含其它结构体也可以使用它们。

```C++
struct Object {
    float first;
    int second;
};

Object scalar = {0.43f, 10};  // One Jbject, with first=0.43f and second=10
Object anArray[] = {{13,4f, 3}, {43.28f, 29}, {5,934f, 17}};  //An array of three Objects
```

对一个静态列表或仅仅是初始化一个结构体得到一个特定值是非常有用的。`C++`也提供了构造函数来初始化一个对象，但是它们并不能和初始化列表一样好用。可是，`C++03`只允许初始化列表在结构体和那些定义为`POD`的类上使用；`C++11`扩展了初始化列表，它们可以被使用在所有类中，包括如`std::vector`这些标准容器中。

`C++11`把这一概念绑定到模板上，称做`std::initializer_list`。它可以允许构造函数和其它的函数接受一个初始化列表作为参数。例如：

```C++
class SequenceClass {
public:
    Sequenceclass(std::initializer_list<int> list);
};
```

这样，`Sequenceclass`就可以通过一个整形序列来构造，如同这样：

```C++
Sequenceclass some_var = {1, 4, 5, 6};
```

这个够构造函数是一个特殊的构造函数，叫做初始化列表构造函数。拥有这一构造函数的类在统一初始化时有不同的处理（见[统一初始化](#统一初始化)。

`std::initializer_list<>`是`C++11`标准库类型的[一流公民][15]。然而，它们仅能够通过`{}`语法被`C++11`编译器静态的初始化构造。
在构造时初始化列表被拷贝一次，尽管只是一次引用拷贝。初始化列表是常量，一旦被创建了它的成员就不能被修改，成员的数据也不能被修改。

因为初始化列表是一个真是的类型，它可以被用在除例类够构造函数之外的其它地方。普通函数可以接受类型化了的初始化列表作为参数。例如：

```C++
void function_name(std::initializer_list<float> list);
function_name({1.0f, -3.45f, -0.4f});
```

标准容器也可以使用下面的方式被初始化：

```C++
std::vector<std::string> v = {"xyzzy", "plugh", "abracadabra"};
std::vector<std::string> v({"xyzzy", "plugh", "abracadabra"});
std::vector<std::string> v{"xyzzy", "plugh", "abracadabra"};  // see "Uniform initialization" below
```

#### 统一初始化

`C++03`在初始化类型时有很多问题。有好几种初始化类型的方式，当互换时它们并不能总是产生相同的结果。例如，传统的构造函数语法看起来像一个函数声明，必须采取措施确保编译器[Most vexing parse][16]不会把它错误的认为是这样。只有集合体和`POD`类型能够使用集合初始化来初始化（使用`SomeType var = {/*stuff*/};`）。

`C++11`提供了一个在任何对象上使用的完全统一类型初始化语法。它扩展了初始化列表语法：

```C++
struct BasicStruct {
    int x;
    double y;
};

struct AltStruct {
    Altstruct(int x, double y) : x_(x), Y-(y) {}

private:
    int x_;
    double y_;
};

Basicstruct var1{5, 3.2};
Altstruct var2{2, 4.3};
```

变量`var1`的初始化行为完全是一个集合初始化。也就是说，对象的每一个数据成员，轮流的，使用初始化列表中相应的值来进行拷贝初始化。隐式类型转换在需要是被使用。如果没有转换存在，或只有一个变窄转换，程序就是不和语法的。变量`var2`的初始化调用了构造函数。

也可以像下面这样做：

```C++
struct IdString {
    std::string name;
    int identifier;
};

IdString get_string() {
    return {"foo", 42};  // Note the lack of explicit type.
}
```

统一初始化不能替代构造函数语法。还有时候，构造函数语法是必须的。如果一个类有一个初始化列表构造函数（`TypeName(initializer_list<SomeType>);`），那么它要优先于其它形式的构造，倘若这个初始化列表符合顺序构造器类型的话。`C++11`版本的`std::vector`为其模板类型提供了一个初始化列表构造函数。这意味着下面的代码：

```C++
std::vector<int> the_vec{4};
```

将会调用初始化列表构造函数，而不是`std::vector`的那个接受单个大小参数并创建这样大小的`vector`的构造函数。为了使用后一种构造函数，用户需要直接使用标准构造函数语法。


#### 类型推断

在`C++03`（和C）中，变量的类型那个必须显示指定以使用它。然而，随着模板类型和模板元编程技术的出现，某些东西的类型，尤其是函数明确定义的返回值，不容易被表达。因此，在变量中存储中间值变得很困难，可能需要一个特定元编程库内部的知识。

`C++11`使用两种方法来缓解这一困境。首先，使用显示初始化定义的变量可以使用`auto`关键字。这会使用初始化器的类型创建一个变量：

```C++
auto some_strange_callable_type = std::bind(&some_function, _2, _1, some_object);
auto other_variable = 5;
```

`some_strange_callable_type`的类型简单的定义为使用那些特定参数特化的模板函数覆盖的`std::bind`的返回值。这一类型非常容易地通过编译器在程序上决定，这是编译器语义分析职责的一部分，但由用户根据视察来确定是不容易的。

`other_variable`的类型也被明确地定义了，但它更容易被用户所确定。它的一个`int`类型，同整形字面值有相同的类型。

此外，关键字`decltype`可以用来在编译时确定表达式的类型。例如：

```C++
int some_int;
decltype(some_int) other_integer_variable = 5;
```

把它和`auto`结合起来会更有用，因为`auto`变量的类型只有编译器才知道。然而，`decltype`也是非常有用的，对那些使用了很多操作符重载和专业类型的代码。

`auto`也有助于减少冗长的代码。例如，不要这样写：

```C++
for(std::vector<int>::const_iterator itr = myvec.cbegin(); itr != myvec.cend(); ++itr)
```

程序员可以使用简短的形式：

```C++
for(auto itr = myvec.begin(); itr != mycec.cend(); ++itr)
```

这还能更进一步压缩，只要"myvec"实现了`begin/end`迭代器：

```C++
for(auto& itr : myvec)
```

这一差异随着程序员开始使用嵌套容器而增长，虽然在这种情况下`typedef`是一个减少代码量很好的方法。

`decltype`表示的类型可以和`auto`推导的不同。

```C++
#include<cector>
int main() {
    const std::vector<int> v(1);
    auto a = v[0];              // a has type int
    decltype(v[1]) b = 1;       // b has type const int&, the return type of
                                //   std::vector<int>::operator[](size_type) const
    auto c = 0;                 // c has type int
    auto d = c;                 // d has tyoe int
    decltype(c) e;              // e has type int, the type of the entity named by c
    decltype((c)) f = c;        // f has type int&, because (c) is an lvalue
    decltype(0) g;              // g has type int, because 0 is an rvalue
```

#### 基于范围的`for`循环

`C++11`扩展了`for`语句的语法来允许在一系列的元素上迭代：

```C++
int my_array[5] = {1, 2, 3, 4, 5};
// double the value of each element in my_array:
for(int &x : my_array) {
    x *= 2;
}
// similar but also using type inference for array elements
for(auto &x : my_array) {
    x *= 2;
}
```

这一形式的`for`被叫做“基于范围的for循环”，将会在列表的每个元素上迭代。它将为C风格的数组、初始化列表、和任何定义的有返回迭代器的`begin()`和`end()`函数的类型工作。所有标准库具有成对的`bengin/end`的容器将可以和基于范围的`for`语句工作。


#### lambda函数和表达式

> 主要文章： [Anonynous function § C++(since C++1)][17]

`C++11`提供了创建[匿名函数][18]，所谓lambda函数，的功能。如同下面这样的定义：

```C++
[](int x, int y) -> int {return x + y;}
```

返回类型是隐式的；它返回`return`表达式（`decltype(x+y)`）的类型。只要`return`表达式返回相同的类型，lambda表达式的返回类型可以省略。lambda函数可选择的作为一个[闭包][19]。


#### 替代函数语法

标准C的函数声明语法能够完美的胜任C语言的特性集。C++是从C进化而来，它保持了基本语法并在需要的地方进行了扩展。然而，随着C++变得更加复杂，它暴露出来许多限制，特别是在模板函数声明时。例如，下面的代码在`C++03`中是不被允许的：

```C++
template<class Lhs, class Rhs>
  Ret adding_func(const Lhs &lhs, const Rhs $rhs) {
      return lhs + rhs;
} // Ret must be the type of lhs+rhs
```

`Ret`的类型是`Lhs`和`Rhs`相加后产生结果的类型。即使使用上述的`C++11`的`decltype`特性，这也是不可能的：

```C++
template<class Lhs, class Rhs>
  decltype(lhs+rhs) adding_func(const Lhs &lhs, const Rhs &rhs) {
      return lhs + rhs;
}  // Not legal C++11
```

在C++中这是非法的，因为`lhs`和`rhs`还没有被定义；它们将不是有效的标识符，直到解析器把剩余的函数原型解析完之后。

为了解决这一问题，`C++11`引入了一个新的函数声明语法，带有一个*尾返回类型*：

```C++
template<class Lhs, class Rhs>
  auto adding_func(const Lhs &lhs, const Rhs &rhs) -> decltype(lhs_rhs)
  {return lhs + rhs;}
```

这一语法可以用于更平凡的函数声明和定义：

```C++
struct SomeStruct {
    auto func_name(int x, int y) -> int;
};

auto SomeStruct::func_name(int x, int y) -> int {
    return x + y;
}
```

在这种情形下使用的`auto`关键字和在自动类型推导中使用的有些不同。


#### 对象构造的改进

在`C++03`中，类的构造函数不允许调用其它的构造函数；每一个构造函数必须自己构造所有的类成员或调用一个普通的成员函数，如同这样：

```C++
class SomeType {
    int number;

private:
    void Construct(int new_number) {number = new_number;}
public:
    SomeType(int new_number) {Construct(new_number);}
    SomeType() {Construct(42);}
};
```

基类的构造函数不能直接暴露在派生类里；每个基类必须实现自己的构造函数即使在基类的构造函数已经适合的情况下。类的非常量数据成员在声明的时候并不能初始化，它们只能在构造函数中初始化。

`C++11`提供了对这些问题的解决方案。

`C++11`允许构造函数调用其它同等的构造函数（被成为[代理][20]）。这使得构造函数使用最少的代码利用其它构造函数的行为。代理已经在其它的语言，例如：Java，中使用了。

语法如下所示：

```C++
class SomeType {
    int number;

public:
    SomeType(int new_number): number(new_number) {}
    SomeType(): SomeType(42) {}
};
```

注意，在这种情况下，

#### 显示的`override`和`final`

#### 空指针常量

#### 强类型的枚举

#### 直角括号

#### 显示的转换操作符

#### 模板别名

#### 无限制的联合体


### 语言核心功能性改进

#### 可变模板

#### 新的字符串字面值

#### 用户自定义字面值

#### 多线程内存模型

#### 线程本地存储

#### 显示的被默认和被删除的特殊成员函数

#### `long long int`类型

#### 静态断言

#### 允许直接在类的成员上使用`sizeof`而不需要显示的对象

#### 控制和查询对象对齐

#### 允许垃圾收集实现

#### 属性


## C++标准库变化

### 升级到标准库组件

### 线程设施

### `tuple`类型

### 哈希表

### 正则表达式

### 通用的智能指针

### 可扩展的随机数设施

### 包装器引用

### 函数对象的多态包装器

### 类型特性的元编程

### 统一的方法计算函数对象的返回类型


## 改善对C的兼容

## 被删除或不包括在内的原计划特性

## 被删除或废弃的特性

## 参见

## 参考

## 外部链接


[1]: http://stackoverflow.com/tags/c%2b%2b11/info
[2]: https://en.wikipedia.org/wiki/International_Organization_for_Standardization
[3]: https://en.wikipedia.org/wiki/C%2B%2B03
[4]: https://en.wikipedia.org/wiki/C%2B%2B14
[5]: https://en.wikipedia.org/wiki/Core_language
[6]: https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library
[7]: https://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1
[8]: http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372
[9]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf
[10]: https://en.wikipedia.org/wiki/ISO/IEC_14882
[11]: https://en.wikipedia.org/wiki/Return_value_optimization
[12]: https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Move_Constructor
[13]: http://en.cppreference.com/w/cpp/container/vector/emplace_back
[14]: https://en.wikipedia.org/wiki/Plain_Old_Data_Structures
[15]: https://en.wikipedia.org/wiki/First-class_citizen
[16]: https://en.wikipedia.org/wiki/Most_vexing_parse
[17]: https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29
[18]: https://en.wikipedia.org/wiki/Anonymous_function
[19]: https://en.wikipedia.org/wiki/Closure_(computer_science)
[20]: https://en.wikipedia.org/wiki/Delegation_(programming)
