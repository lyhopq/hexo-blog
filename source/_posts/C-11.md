title: C++11
date: 2015-06-27 09:40:50
categories: [C/C++,翻译]
tags: C++11
---

译自：https://en.wikipedia.org/wiki/C++11

`C++11`（原先被称作`C++0x`，[因为它是被预计在2010之前发布](http://stackoverflow.com/tags/c%2b%2b11/info)）是[C++语言](https://en.wikipedia.org/wiki/C%2B%2B)标准的一个版本。它被[`ISO`](https://en.wikipedia.org/wiki/International_Organization_for_Standardization)在2011年8月12日批准，来替代[`C++03`](https://en.wikipedia.org/wiki/C%2B%2B03)的，并且在2014年8月18日被[`C++14`](https://en.wikipedia.org/wiki/C%2B%2B14)取代。命名沿用了语言版本的传统命名方式：根据规范的发布年限。

`C++11`对[语言核心](https://en.wikipedia.org/wiki/Core_language)增加了一些特性，扩展了[C++标准库](https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library)，合并了[技术报告1]](https://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1)(TR1)中的大多数库--除了数学专用函数库以外。`C++11`在2011年9月作为[`ISO/IEC
14882:2011`](http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372)标准被发布，而且它是收费的。最接近已发布的`C++11`标准的工作草案是[`N3337`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf)，于2012年1月16日发布；它只包括`C++11`标准的编辑修正。

## 相对前一标准版本的变化

C++的条款修订包含语言核心和标准库两个方面。

2011标准的每一个设施的制定，委员会都会运用一些准则：
- 保持稳定、兼容[`C++98`](https://en.wikipedia.org/wiki/ISO/IEC_14882)和尽可能兼容C
- 宁愿使用标准库来引入新特性，而不扩展语言核心
- 做出改变来发展编程技术
- 改进C++来增强系统和库的设计，而不是只为了特定应用增加新特性
- 通过对先前不安全的技术提供更安全的替代方案，来增加类型安全性
- 提升性能和直接于硬件工作的能力
- 为现实问题提供适当的解决方案
- 实施“零开销”原则（如果使用某些设施，那么它所需要的附加支持也必须要被使用）
- 使得C++容易被教授和学习，而不需要去掉一些被专家程序员使用的设施

关注初学者被认为是是重要的，因为他们总是构成计算机程序员的大多数；而且许多初学者不打算扩展他们的C++知识，这样就限制了他们只运用语言与他们专业相关的一些方面。

## 对C++语言核心的扩展

C++委员会的一个职责是发展语言核心。语言核心领域的改进意义重大，包括：多线程支持、泛型编程支持、统一初始化和性能。
为了本文的需要，语言核心特性和其改变被分为四个通用的部分：运行时性能增强、编译时性能增强、易用性增强和新功能。某些特性可以被归在多个组里，但它们只在最能代表它的组里被提到。

### 语言核心运行时性能增强

这些语言特性的存在主要是为了提供一些性能增益，无论是内存还是运算速度。

#### 右值引用和移动构造函数

在`C++03`（和以前），临时变量（术语"rvalues"，因为它们常常在赋值的右边）是为了不被修改--就现在C中一样--而且被认为同`const T&`类型区分开来；然而，有时候，临时变量可以被修改，这一行为甚至被认为是一个有用的漏洞。`C++11`新曾了一个叫右值引用的非常量引用，定义为`T&&`。它是指临时变量在初始化之后可以被修改，目的是为了允许“移动语义”。

`C++03`带来的一个长期的性能问题是：当对象通过值传递时代价高的和不必要的深拷贝会暗地里发生。为了阐明这个问题，暂且把`std::vector<T>`在内部认为是一个带有大小的C风格数组的包装。如果一个`std::vector<T>`临时变量被创建或被一个函数返回，它只可以通过新创建一个`std::vector<T>`来存储，并拷贝右值的所有数据到它里面。然后，这个临时变量和它的所有内存被销毁。（为了简单起见，这一讨论忽略了[返回值优化](https://en.wikipedia.org/wiki/Return_value_optimization)。）

在`C++11`中，`std::vector<T>`的[移动构造函数](https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Move_Constructor)可以接受一个`std::vector<T>`类型的右值引用，能够从该右值中复制那个内部C风格数组的指针到这个新的`std::vector<T>`中，然后把右值内部的指针设为空。由于这个临时变量不会再被使用，没有代码会试图去访问这个空指针，并且因为这个指针是个空指针，当它超出作用域时，它的内存并不会被删除。因此，这一操作不仅去掉了深拷贝的开销，而且是安全和无形的。

右值引用可以在对标准库之外的现有代码不做任何改变的基础上带来性能优势。返回`std::vector<T>`的函数的返回值不用显示的改变成`std::vector<T> &&`来调用移动构造函数，因为临时变量会自动的被认为是右值。（然而，如果`std::vector<T>`是`C++03`版本的，没有移动构造函数，那么拷贝构造函数就会通过`const std::vector<T>&`被调用，导致一个大内存被分配。）

出于安全原因，加了一些限制。一个命名变量绝不会被认为是一个右值，即使它声明成这样；应该使用模板函数`std::move()`来得到一个右值。右值引用也只能在某些情况下被修改，其目的主要是同移动构造函数一起使用。

归因于右值引用语法的性质，和对左值引用语法（常规引用）的一些修改，右值引用允许开发者提供完美的函数转发。当结合[可变模板](https://en.wikipedia.org/wiki/C++11#Variadic_templates)时，这一能力允许函数模板能够完美的转发参数给其它接受相同特定参数的函数。用它来转发够构造函数的参数非常有用：使用它创建一个工厂函数，工厂函数会自动的为这些特定的参数调用正确的构造函数。这已在[emplace_back](http://en.cppreference.com/w/cpp/container/vector/emplace_back)，C++的标准库方法集，中见到过了。

#### `constexpr` -- 广义的常量表达式

C++一直拥有常量表达式的概念。它们是如同`3+4`这样总是在编译时和运行时产生同样结果的表达式。常量表达式是编译器进行优化的机会，编译器经常在编译时执行它们，而把结果硬编码到程序里。而且，在许多地方，C++标准指出要使用常量表达式。定义一个数组需要一个常量表达式，枚举值必须是常量表达式。

然而，常量表达式从来并没有被允许包含一个函数调用或者一个对象构造函数。因此，如同这样简单的代码是非法的：

```C++
int get_five() {return 5;}
int some_value[get_five() + 7];  // Create an array of 12 integets. Ill-formed C++
```

在`C++03`中这不合法，因为`get_five() + 7`并不是一个常量表达式。`C++03`的编译器并没有方法知道`get_five`在运行时确实是一个常量。理论上，这一函数可能会影响一个全局变量，调用其它的非运行时常量函数，等等。

`C++11`引入了`constexpr`关键字，允许用户保证一个函数或对象构造函数是一个编译时常量。上面的例子可以被重写为一下形式：

```C++
constexpr int get_five() {return 5;}
int some_value[get_five() + 7];  // Create an array of 12 integets. Legal C++11
```

这使得编译器理解、证实`get_five()`是一个编译时常量。

在函数上使用`constexpr`会给该函数所做的事情强加一些限制。首先，该函数必须有一个非空的返回类型。第二，函数体不能声明变量或定义新类型。第三，函数体只能包含声明、空语句和一条`ruturn`语句；`return`语句必须存在参数值，以至于在参数替换之后，`return`语句的表达式产生一个常量表达式。

在`C++11`以前，变量的值只有在变量被声明为`const`，并且有一个常量表达式的初始化式，而且只能是整形或枚举类型 的情况下，才可以用在常量表达式中。`C++11`去掉了变量必须是整形或枚举这一限制，如果在它们使用`constexpr`关键字来定义：

```C++
constexpr double earth_gravitational_acceleration = 9.8;
constexpr double moon_gravitational_acceleration = earth_gravitational_acceleration / 6.0;
```

这些数据变量是隐式的常量，它们必须有初始化式，且初始化式必须是常量表达式。

为了从用户自定义类型来构造常量表达式数据值，构造函数也必须用`constexpr`声明。一个`constexpr`构造函数的函数体只能包含声明和空语句，不能声明变量或定义类型，如同一个`constexpr`函数一样。必须存在参数值，以至于在参数替换之后，把类成员初始化为常量表达式。这种类型的析构函数必须是不重要的。

具有任何`constexpr`构造函数的类型，它的拷贝构造函数通常也应该被定义为一个`constexpr`构造函数，为了让该类型的对象能够从一个`constexpr`函数中以值的方式返回。一个类的任何成员函数，例如：拷贝构造函数、操作符重载等等，都可以被声明为`constexpr`，只要它们被`constexpr`函数所需要。这使得编译器在编译时拷贝类、在它们上执行操作，等等。

如果一个`constexpr`函数或构造函数被使用非常量表达式的参数调用，那么这个调用行为就像该函数不是一个`constexpr`一样，其返回值也不是一个常量表达式。同样的，如果一个`constexpr`函数的`return`语句中的表达式对于一个特定的调用不能求值成一个常量表达式，那么其返回值也不是一个常量表达式。

#### 修改对`plain old data`的定义

在`C++03`中，一个类或结构体必须遵守许多规则才被认为是[`plain old
data`](https://en.wikipedia.org/wiki/Plain_Old_Data_Structures)(POD)类型。符合这一定义的类型产生的对象布局是于C兼容的，并且它们被静态的初始化。`C++03`标准对什么样的类型是C兼容的或能够被静态初始化的具有限制，尽管没有技术上的原因使编译器不能接受；如果有人创建了一个`C++03`的`POD`类型，但在它上面增加了一个非虚的成员函数，那么这个类型就不在是一个`POD`类型了，不能够被静态初始化，也不能于C兼容了，尽管在内存结构上没有变化。


