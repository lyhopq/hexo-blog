{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[],"Cache":[{"_id":"source/_posts/C语言结构体对齐算法.md","shasum":"8af0dbd3dbfc1f448d2e24ab20c8772348529f7c","modified":1434760787039},{"_id":"source/_posts/gitignore妙用.md","shasum":"3d409c0d6aaa91818311e0389ccaf1668c9252f3","modified":1434760787039},{"_id":"public/2013/10/23/C语言结构体对齐算法/index.html","modified":1434761001085,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/2013/10/20/gitignore妙用/index.html","modified":1434761001089,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/index.html","modified":1434761001091,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/2013/index.html","modified":1434761001092,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/archives/2013/10/index.html","modified":1434761001093,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/index.html","modified":1434761001094,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/tags/结构体对齐/index.html","modified":1434761001095,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/tags/算法/index.html","modified":1434761001096,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/tags/Git/index.html","modified":1434761001097,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"},{"_id":"public/tags/gitignore/index.html","modified":1434761001098,"shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709"}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"C语言结构体对齐算法","date":"2013-10-23T07:20:16.000Z","_content":"\n最近做了一个关于结构体补齐填充的东西，补了一下关于结构体对齐方面的知识（以前也研究过，不过都忘了，所以在这记录一下）。\n\n\n首先看一下结构体对齐的三个概念值： \n\n1\t数据类型的*默认对齐值*（自身对齐）\n  * 基本数据类型：为指定平台上基本类型的长度。如在32位机器中，char对齐值为1，short为2，int,float为4，double为8；\n  * 结构体：其数据成员中默认对齐值最大的那个值。\n    \n2\t*指定对齐值*：#pragma pack (value)时的指定对齐值value。 \n3\t数据类型的*有效对齐值*：默认对齐值和指定对齐值中小的那个值。\n\n有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的`偏移量`%N=0”。而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放（对于非对齐成员需要在其前面填充一些字节，保证其在对齐位置上），结构体本身也要根据自身的有效对齐值圆整(就是结`构体总长度`需要是结构体有效对齐值的整数倍)。\n\n通过上面的分析，对结构体进行字节对齐，我们需要知道四个值：\n1\t指定对齐值：代码中指定的对齐值，记为packLen；\n2\t默认对齐值：结构体中每个数据成员及结构体本身都有默认对齐值，记为defaultLen；\n3\t成员偏移量：即相对于结构体起始位置的长度，记为offset；\n4\t成员长度：结构体中每个数据成员的长度（注结构体成员为补齐之后的长度），记为memberLen。\n\n及两个规则：\n1\t对齐规则：`offset % vaildLen = 0`，其中vaildLen为有效对齐值`vaildLen = min(packLen, defaultLen)`；\n2\t填充规则：如成员变量不遵守对齐规则，则需要对其补齐；在其前面填充一些字节保证该成员对齐。需填充的字节数记为padLen：\n\n    ```\n    padLen = getPadLen(offset , defaultLen);\n    \n    int getPadLen(int offsetLen, int defaultLen)\n    {\n        int vaildLen = min(packLen,defaultLen);\n        if(0 == vaildLen || 0 == offsetLen % vaildLen)\n        {\n            return 0;\n        }\n        return vaildLen - (offsetLen % vaildLen);\n    }\n    ```\n     \n\n结构体对齐算法思想：深度优先填充\n1\t先对齐内层结构体；\n2\t对每个数据成员计算其`defaultLen`、`memberLen`和`offset`；\n    a\t在遍历每个数据成员时计算；\n    b\t对于基本数据类型成员`defaultLen=memberLen`；对于结构体成员`defaultLen`等于它的所有成员的最大的`memberLen`；\n    c\t遍历时对成员的`memberLen`进行累加，得到当前成员的`offsetLen`；\n3\t运用对齐及填充规则：在当前结构体成员前填充padLen个字节；\n","source":"_posts/C语言结构体对齐算法.md","raw":"title: C语言结构体对齐算法\ndate: 2013-10-23 15:20:16\ntags: [结构体对齐,算法]\n\n---\n\n最近做了一个关于结构体补齐填充的东西，补了一下关于结构体对齐方面的知识（以前也研究过，不过都忘了，所以在这记录一下）。\n\n\n首先看一下结构体对齐的三个概念值： \n\n1\t数据类型的*默认对齐值*（自身对齐）\n  * 基本数据类型：为指定平台上基本类型的长度。如在32位机器中，char对齐值为1，short为2，int,float为4，double为8；\n  * 结构体：其数据成员中默认对齐值最大的那个值。\n    \n2\t*指定对齐值*：#pragma pack (value)时的指定对齐值value。 \n3\t数据类型的*有效对齐值*：默认对齐值和指定对齐值中小的那个值。\n\n有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的`偏移量`%N=0”。而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放（对于非对齐成员需要在其前面填充一些字节，保证其在对齐位置上），结构体本身也要根据自身的有效对齐值圆整(就是结`构体总长度`需要是结构体有效对齐值的整数倍)。\n\n通过上面的分析，对结构体进行字节对齐，我们需要知道四个值：\n1\t指定对齐值：代码中指定的对齐值，记为packLen；\n2\t默认对齐值：结构体中每个数据成员及结构体本身都有默认对齐值，记为defaultLen；\n3\t成员偏移量：即相对于结构体起始位置的长度，记为offset；\n4\t成员长度：结构体中每个数据成员的长度（注结构体成员为补齐之后的长度），记为memberLen。\n\n及两个规则：\n1\t对齐规则：`offset % vaildLen = 0`，其中vaildLen为有效对齐值`vaildLen = min(packLen, defaultLen)`；\n2\t填充规则：如成员变量不遵守对齐规则，则需要对其补齐；在其前面填充一些字节保证该成员对齐。需填充的字节数记为padLen：\n\n    ```\n    padLen = getPadLen(offset , defaultLen);\n    \n    int getPadLen(int offsetLen, int defaultLen)\n    {\n        int vaildLen = min(packLen,defaultLen);\n        if(0 == vaildLen || 0 == offsetLen % vaildLen)\n        {\n            return 0;\n        }\n        return vaildLen - (offsetLen % vaildLen);\n    }\n    ```\n     \n\n结构体对齐算法思想：深度优先填充\n1\t先对齐内层结构体；\n2\t对每个数据成员计算其`defaultLen`、`memberLen`和`offset`；\n    a\t在遍历每个数据成员时计算；\n    b\t对于基本数据类型成员`defaultLen=memberLen`；对于结构体成员`defaultLen`等于它的所有成员的最大的`memberLen`；\n    c\t遍历时对成员的`memberLen`进行累加，得到当前成员的`offsetLen`；\n3\t运用对齐及填充规则：在当前结构体成员前填充padLen个字节；\n","slug":"C语言结构体对齐算法","published":1,"updated":"2015-06-20T00:39:47.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cib4bnl4j0000ay9gkx5i0iy8"},{"title":"gitignore妙用","date":"2013-10-20T07:20:16.000Z","_content":"\n使用Git的同学都知道`.gitignore` 配置文件用于配置不需要加入版本管理的文件，对版本管理带来很大的便利。今天有个需求就是忽略版本库下除少数几个文件和文件夹之外的所有文件，首先想到的方式是使用gitignore树的概念，即在需要的文件夹下都添加`.gitignore`文件，并在其中设定相应的规则。但是，这种方式比较麻烦。\n\n好好研究了一下`gitignore`的语法，知道了`.gitignore`文件过滤有两种模式：开放模式和保守模式。\n\n1. 开放模式负责设置过滤哪些文件和文件夹\n\n    例如： \n    \n    /target/ 表示项目根目录下的target文件夹里面所有的内容都会被过滤，不被跟踪\n    .classpath 表示项目根目录下的.classpath文件会被过滤，不被跟踪\n \n2. 保守模式负责设置哪些文件不被过滤，也就是哪些文件要被跟踪\n\n    例如：\n\n    !/target/*.h 表示target文件夹目录下所有的.h文件将被跟踪\n  \n\n还有就是，`gitignore`是从上到下逐行匹配的，因此`.gitignore`文件的编写原则就是：\n\n> 先编写开放模式，在编写保守模式\n\n要不然，开放模式的规则会把保守模式的规则给覆盖了。\n\n下面附上我的`.gitignore`文件的示例：\n\n```\n/*\n!.gitignore\n!/posts/\n```\n\n只跟踪版本库中的`.gitignore`文件和`posts`目录。这里需要注意的是：\n\n> 一定是`/\\*`而不是`\\*`，`/\\*`表示当前目录下的所有文件，而不是所有文件`\\*`；（这是我自己的理解，不知道对不对！）\n\n下面附上`gitignore`的简单语法：\n\n> 以斜杠“/”开头表目录\n\n> 以星号“*”通配多字符\n\n> 以问号“?”通配单字符\n\n> 以方括号“[]”包含单个字符的匹列表\n\n> 以叹号“!”对匹配结果反\n\n","source":"_posts/gitignore妙用.md","raw":"---\ntitle: gitignore妙用\ndate: 2013-10-20 15:20:16\n\ntags: [Git,gitignore]\n\n---\n\n使用Git的同学都知道`.gitignore` 配置文件用于配置不需要加入版本管理的文件，对版本管理带来很大的便利。今天有个需求就是忽略版本库下除少数几个文件和文件夹之外的所有文件，首先想到的方式是使用gitignore树的概念，即在需要的文件夹下都添加`.gitignore`文件，并在其中设定相应的规则。但是，这种方式比较麻烦。\n\n好好研究了一下`gitignore`的语法，知道了`.gitignore`文件过滤有两种模式：开放模式和保守模式。\n\n1. 开放模式负责设置过滤哪些文件和文件夹\n\n    例如： \n    \n    /target/ 表示项目根目录下的target文件夹里面所有的内容都会被过滤，不被跟踪\n    .classpath 表示项目根目录下的.classpath文件会被过滤，不被跟踪\n \n2. 保守模式负责设置哪些文件不被过滤，也就是哪些文件要被跟踪\n\n    例如：\n\n    !/target/*.h 表示target文件夹目录下所有的.h文件将被跟踪\n  \n\n还有就是，`gitignore`是从上到下逐行匹配的，因此`.gitignore`文件的编写原则就是：\n\n> 先编写开放模式，在编写保守模式\n\n要不然，开放模式的规则会把保守模式的规则给覆盖了。\n\n下面附上我的`.gitignore`文件的示例：\n\n```\n/*\n!.gitignore\n!/posts/\n```\n\n只跟踪版本库中的`.gitignore`文件和`posts`目录。这里需要注意的是：\n\n> 一定是`/\\*`而不是`\\*`，`/\\*`表示当前目录下的所有文件，而不是所有文件`\\*`；（这是我自己的理解，不知道对不对！）\n\n下面附上`gitignore`的简单语法：\n\n> 以斜杠“/”开头表目录\n\n> 以星号“*”通配多字符\n\n> 以问号“?”通配单字符\n\n> 以方括号“[]”包含单个字符的匹列表\n\n> 以叹号“!”对匹配结果反\n\n","slug":"gitignore妙用","published":1,"updated":"2015-06-20T00:39:47.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cib4bnl4x0005ay9gz956c6i4"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cib4bnl4j0000ay9gkx5i0iy8","tag_id":"cib4bnl4q0001ay9g9wrn9jpj","_id":"cib4bnl4t0003ay9gghiuezf8"},{"post_id":"cib4bnl4j0000ay9gkx5i0iy8","tag_id":"cib4bnl4s0002ay9g19rt9syh","_id":"cib4bnl4t0004ay9glt9pxkes"},{"post_id":"cib4bnl4x0005ay9gz956c6i4","tag_id":"cib4bnl4z0006ay9gwvg311jv","_id":"cib4bnl500008ay9g18gnv7zq"},{"post_id":"cib4bnl4x0005ay9gz956c6i4","tag_id":"cib4bnl4z0007ay9ggn4d975o","_id":"cib4bnl500009ay9gir1fw6ni"}],"Tag":[{"name":"结构体对齐","_id":"cib4bnl4q0001ay9g9wrn9jpj"},{"name":"算法","_id":"cib4bnl4s0002ay9g19rt9syh"},{"name":"Git","_id":"cib4bnl4z0006ay9gwvg311jv"},{"name":"gitignore","_id":"cib4bnl4z0007ay9ggn4d975o"}]}}